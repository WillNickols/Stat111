tmp_betas <- out_mat[i,]
tmp_betas[j] <- proposed_beta
next_lik <- log_likelihood(tmp_betas, sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
out_mat[i,] <- tmp_betas
}
}
# Mu update
proposed_mu <- mu_vec[i - 1] + rnorm(1, 0, 1)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], proposed_mu,
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
mu_vec[i] <- proposed_mu
} else {
mu_vec[i] <- mu_vec[i - 1]
}
# Sigma beta squared update
proposed_sigma_sq_beta <- sigma_sq_beta_vec[i - 1] + rnorm(1, 0, 0.00001)
if (proposed_sigma_sq_beta <= 0) {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
proposed_sigma_sq_beta)
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq_beta_vec[i] <- proposed_sigma_sq_beta
} else {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
}
}
}
# Burn in
out_mat <- out_mat[-c(1:nsamp/10),]
sigma_sq <- sigma_sq[-c(1:nsamp/10)]
mu_vec <- mu_vec[-c(1:nsamp/10)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[-c(1:nsamp/10)]
# Prune
out_mat <- out_mat[seq(2, nrow(out_mat), 100),]
sigma_sq <- sigma_sq[seq(2, length(sigma_sq), 100)]
mu_vec <- mu_vec[seq(2, length(mu_vec), 100)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[seq(2, length(sigma_sq_beta_vec), 100)]
joined_df <- data.frame(cbind(out_mat, sigma_sq, mu_vec, sigma_sq_beta_vec))
colnames(joined_df) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
joined_df$Iter <- 1:nrow(joined_df)
joined_df <- melt(joined_df, id.vars = c("Iter"))
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free", )
# Print summaries
print_table <- data.frame(rbind(round(colMeans(out_mat), 3),
round(apply(out_mat, 2, median), 3),
round(apply(out_mat, 2, sd), 3)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 3)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 3)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 3)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free", )
set.seed(220)
B_hat <- chol2inv(chol(t(X) %*% X)) %*% t(X) %*% y
V_b <- chol2inv(chol(t(X) %*% X))
# Log likelihood of full model for Metropolis
log_likelihood <- function(betas, sigma_sq, mu, sigma_sq_beta) {
mus <- X %*% betas
V <- sigma_sq * diag(length(y))
mvnorm_piece <- -k/2 * log(2 * pi) - 1/2 * log(det(V)) -
1/2 * t(y - mus) %*% solve(V) %*% (y - mus)
prior_piece <- - log(sqrt(sigma_sq)) +
sum(log(dnorm(betas[2:length(betas)], mu, sqrt(sigma_sq_beta))))
return (mvnorm_piece + prior_piece)
}
nsamp <- 10^6
sigma_sq <- vector(length = nsamp)
out_mat <- matrix(nrow = nsamp, ncol = k)
mu_vec <- vector(length = nsamp)
sigma_sq_beta_vec <- vector(length = nsamp)
# Reasonable starting values
sigma_sq[1] <- 4
out_mat[1,] <- c(-60, rep(0, k - 1))
mu_vec[1] <- 0
sigma_sq_beta_vec[1] <- 0.00001
# Metropolis sample from posterior
for (i in 2:nsamp) {
# Sigma squared update
proposed_sigma_sq <- sigma_sq[i - 1] + rnorm(1, 0, 1)
if (proposed_sigma_sq <= 0) {
sigma_sq[i] <- sigma_sq[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i - 1,], sigma_sq[i - 1],
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i - 1,], proposed_sigma_sq,
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq[i] <- proposed_sigma_sq
} else {
sigma_sq[i] <- sigma_sq[i - 1]
}
}
out_mat[i,] <- out_mat[i - 1,]
# Update beta
for (j in 1:k) {
proposed_beta <- out_mat[i, j] + rnorm(1, 0, abs(out_mat[i, j])/10 + 0.001)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
tmp_betas <- out_mat[i,]
tmp_betas[j] <- proposed_beta
next_lik <- log_likelihood(tmp_betas, sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
out_mat[i,] <- tmp_betas
}
}
# Mu update
proposed_mu <- mu_vec[i - 1] + rnorm(1, 0, 1)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], proposed_mu,
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
mu_vec[i] <- proposed_mu
} else {
mu_vec[i] <- mu_vec[i - 1]
}
# Sigma beta squared update
proposed_sigma_sq_beta <- sigma_sq_beta_vec[i - 1] + rnorm(1, 0, 0.00001)
if (proposed_sigma_sq_beta <= 0) {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
proposed_sigma_sq_beta)
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq_beta_vec[i] <- proposed_sigma_sq_beta
} else {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
}
}
}
# Burn in
out_mat <- out_mat[-c(1:nsamp/10),]
sigma_sq <- sigma_sq[-c(1:nsamp/10)]
mu_vec <- mu_vec[-c(1:nsamp/10)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[-c(1:nsamp/10)]
# Prune
out_mat <- out_mat[seq(2, nrow(out_mat), 100),]
sigma_sq <- sigma_sq[seq(2, length(sigma_sq), 100)]
mu_vec <- mu_vec[seq(2, length(mu_vec), 100)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[seq(2, length(sigma_sq_beta_vec), 100)]
joined_df <- data.frame(cbind(out_mat, sigma_sq, mu_vec, sigma_sq_beta_vec))
colnames(joined_df) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
joined_df$Iter <- 1:nrow(joined_df)
joined_df <- melt(joined_df, id.vars = c("Iter"))
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
# Print summaries
print_table <- data.frame(rbind(round(colMeans(out_mat), 3),
round(apply(out_mat, 2, median), 3),
round(apply(out_mat, 2, sd), 3)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 3)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 3)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 3)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
1:2*3
set.seed(220)
B_hat <- chol2inv(chol(t(X) %*% X)) %*% t(X) %*% y
V_b <- chol2inv(chol(t(X) %*% X))
# Log likelihood of full model for Metropolis
log_likelihood <- function(betas, sigma_sq, mu, sigma_sq_beta) {
mus <- X %*% betas
V <- sigma_sq * diag(length(y))
mvnorm_piece <- -k/2 * log(2 * pi) - 1/2 * log(det(V)) -
1/2 * t(y - mus) %*% solve(V) %*% (y - mus)
prior_piece <- - log(sqrt(sigma_sq)) +
sum(log(dnorm(betas[2:length(betas)], mu, sqrt(sigma_sq_beta))))
return (mvnorm_piece + prior_piece)
}
nsamp <- 10^6
sigma_sq <- vector(length = nsamp)
out_mat <- matrix(nrow = nsamp, ncol = k)
mu_vec <- vector(length = nsamp)
sigma_sq_beta_vec <- vector(length = nsamp)
# Reasonable starting values
sigma_sq[1] <- 4
out_mat[1,] <- c(-60, rep(0, k - 1))
mu_vec[1] <- 0
sigma_sq_beta_vec[1] <- 0.00001
# Metropolis sample from posterior
for (i in 2:nsamp) {
# Sigma squared update
proposed_sigma_sq <- sigma_sq[i - 1] + rnorm(1, 0, 1)
if (proposed_sigma_sq <= 0) {
sigma_sq[i] <- sigma_sq[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i - 1,], sigma_sq[i - 1],
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i - 1,], proposed_sigma_sq,
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq[i] <- proposed_sigma_sq
} else {
sigma_sq[i] <- sigma_sq[i - 1]
}
}
out_mat[i,] <- out_mat[i - 1,]
# Update beta
for (j in 1:k) {
proposed_beta <- out_mat[i, j] + rnorm(1, 0, abs(out_mat[i, j])/10 + 0.001)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
tmp_betas <- out_mat[i,]
tmp_betas[j] <- proposed_beta
next_lik <- log_likelihood(tmp_betas, sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
out_mat[i,] <- tmp_betas
}
}
# Mu update
proposed_mu <- mu_vec[i - 1] + rnorm(1, 0, 1)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], proposed_mu,
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
mu_vec[i] <- proposed_mu
} else {
mu_vec[i] <- mu_vec[i - 1]
}
# Sigma beta squared update
proposed_sigma_sq_beta <- sigma_sq_beta_vec[i - 1] + rnorm(1, 0, 0.00001)
if (proposed_sigma_sq_beta <= 0) {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
proposed_sigma_sq_beta)
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq_beta_vec[i] <- proposed_sigma_sq_beta
} else {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
}
}
}
# Burn in
out_mat <- out_mat[-c(1:(nsamp * 3/10)),]
sigma_sq <- sigma_sq[-c(1:(nsamp * 3/10))]
mu_vec <- mu_vec[-c(1:(nsamp * 3/10))]
sigma_sq_beta_vec <- sigma_sq_beta_vec[-c(1:(nsamp * 3/10))]
# Prune
out_mat <- out_mat[seq(2, nrow(out_mat), 100),]
sigma_sq <- sigma_sq[seq(2, length(sigma_sq), 100)]
mu_vec <- mu_vec[seq(2, length(mu_vec), 100)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[seq(2, length(sigma_sq_beta_vec), 100)]
joined_df <- data.frame(cbind(out_mat, sigma_sq, mu_vec, sigma_sq_beta_vec))
colnames(joined_df) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
joined_df$Iter <- 1:nrow(joined_df)
joined_df <- melt(joined_df, id.vars = c("Iter"))
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
# Print summaries
print_table <- data.frame(rbind(round(colMeans(out_mat), 3),
round(apply(out_mat, 2, median), 3),
round(apply(out_mat, 2, sd), 3)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 3)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 3)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 3)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
set.seed(220)
B_hat <- chol2inv(chol(t(X) %*% X)) %*% t(X) %*% y
V_b <- chol2inv(chol(t(X) %*% X))
# Log likelihood of full model for Metropolis
log_likelihood <- function(betas, sigma_sq, mu, sigma_sq_beta) {
mus <- X %*% betas
V <- sigma_sq * diag(length(y))
mvnorm_piece <- -k/2 * log(2 * pi) - 1/2 * log(det(V)) -
1/2 * t(y - mus) %*% solve(V) %*% (y - mus)
prior_piece <- - log(sqrt(sigma_sq)) +
sum(log(dnorm(betas[2:length(betas)], mu, sqrt(sigma_sq_beta))))
return (mvnorm_piece + prior_piece)
}
nsamp <- 10^6
sigma_sq <- vector(length = nsamp)
out_mat <- matrix(nrow = nsamp, ncol = k)
mu_vec <- vector(length = nsamp)
sigma_sq_beta_vec <- vector(length = nsamp)
# Reasonable starting values
sigma_sq[1] <- 4
out_mat[1,] <- c(-60, rep(0, k - 1))
mu_vec[1] <- 0
sigma_sq_beta_vec[1] <- 0.00001
# Metropolis sample from posterior
for (i in 2:nsamp) {
# Sigma squared update
proposed_sigma_sq <- sigma_sq[i - 1] + rnorm(1, 0, 1)
if (proposed_sigma_sq <= 0) {
sigma_sq[i] <- sigma_sq[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i - 1,], sigma_sq[i - 1],
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i - 1,], proposed_sigma_sq,
mu_vec[i - 1], sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq[i] <- proposed_sigma_sq
} else {
sigma_sq[i] <- sigma_sq[i - 1]
}
}
out_mat[i,] <- out_mat[i - 1,]
# Update beta
for (j in 1:k) {
proposed_beta <- out_mat[i, j] + rnorm(1, 0, abs(out_mat[i, j])/10 + 0.001)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
tmp_betas <- out_mat[i,]
tmp_betas[j] <- proposed_beta
next_lik <- log_likelihood(tmp_betas, sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
out_mat[i,] <- tmp_betas
}
}
# Mu update
proposed_mu <- mu_vec[i - 1] + rnorm(1, 0, 1)
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i - 1],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], proposed_mu,
sigma_sq_beta_vec[i - 1])
A = exp(next_lik - cur_lik)
if(runif(1) < A){
mu_vec[i] <- proposed_mu
} else {
mu_vec[i] <- mu_vec[i - 1]
}
# Sigma beta squared update
proposed_sigma_sq_beta <- sigma_sq_beta_vec[i - 1] + rnorm(1, 0, 0.00001)
if (proposed_sigma_sq_beta <= 0) {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
} else {
cur_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
sigma_sq_beta_vec[i - 1])
next_lik <- log_likelihood(out_mat[i,], sigma_sq[i], mu_vec[i],
proposed_sigma_sq_beta)
A = exp(next_lik - cur_lik)
if(runif(1) < A){
sigma_sq_beta_vec[i] <- proposed_sigma_sq_beta
} else {
sigma_sq_beta_vec[i] <- sigma_sq_beta_vec[i - 1]
}
}
}
# Burn in
out_mat <- out_mat[-c(1:(nsamp * 5/10)),]
sigma_sq <- sigma_sq[-c(1:(nsamp * 5/10))]
mu_vec <- mu_vec[-c(1:(nsamp * 5/10))]
sigma_sq_beta_vec <- sigma_sq_beta_vec[-c(1:(nsamp * 5/10))]
# Prune
out_mat <- out_mat[seq(2, nrow(out_mat), 100),]
sigma_sq <- sigma_sq[seq(2, length(sigma_sq), 100)]
mu_vec <- mu_vec[seq(2, length(mu_vec), 100)]
sigma_sq_beta_vec <- sigma_sq_beta_vec[seq(2, length(sigma_sq_beta_vec), 100)]
joined_df <- data.frame(cbind(out_mat, sigma_sq, mu_vec, sigma_sq_beta_vec))
colnames(joined_df) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
joined_df$Iter <- 1:nrow(joined_df)
joined_df <- melt(joined_df, id.vars = c("Iter"))
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
# Print summaries
print_table <- data.frame(rbind(round(colMeans(out_mat), 3),
round(apply(out_mat, 2, median), 3),
round(apply(out_mat, 2, sd), 3)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 3)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 3)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 3)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
knitr::kable(print_table)
print_table <- data.frame(rbind(round(colMeans(out_mat), 4),
round(apply(out_mat, 2, median), 4),
round(apply(out_mat, 2, sd), 4)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 4)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 4)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 4)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
print_table <- data.frame(rbind(round(colMeans(out_mat), 5),
round(apply(out_mat, 2, median), 5),
round(apply(out_mat, 2, sd), 5)))
print_table$sigma <- round(c(mean(sqrt(sigma_sq)), median(sqrt(sigma_sq)),
sd(sqrt(sigma_sq))), 5)
print_table$mu <- round(c(mean(mu_vec), median(mu_vec), sd(mu_vec)), 5)
print_table$sigma_sq_beta <- round(c(mean(sqrt(sigma_sq_beta_vec)),
median(sqrt(sigma_sq_beta_vec)),
sd(sqrt(sigma_sq_beta_vec))), 5)
colnames(print_table) <- c(colnames(X), "Sigma", "Mu", "Sigma beta")
rownames(print_table) <- c("Mean", "Median", "SD")
knitr::kable(print_table)
ggplot(joined_df, aes(x = Iter, y = value)) +
geom_point() +
facet_wrap(vars(variable), scales = "free")
mean(100 - rgamma(10000, 18, 0.1))
mean(100 - rgamma(10000, 1.8, 0.1))
var(100 - rgamma(10000, 1.8, 0.1))
sd(100 - rgamma(10000, 1.8, 0.1))
median(100 - rgamma(10000, 1.8, 0.1))
hist(100 - rgamma(10000, 1.8, 0.1))
quantile(100 - rgamma(10000, 1.8, 0.1), c(0.9))
quantile(100 - rgamma(10000, 1.8, 0.1), c(0.7))
set.seed(220)
# Data
ys <- c(28, 8, -3, 7, -1, 1, 18, 12)
sigma_sqs <- c(15, 10, 16, 11, 9, 11, 10, 18)^2
nsamp <- 10^4
# Probability of tau
p_tau <- function(tau) {
mu_hat <- sum(1/(sigma_sqs + tau^2) * ys) / sum(1/(sigma_sqs + tau^2))
return (1/sqrt(sum(1/(sigma_sqs + tau^2))) *
prod(1/sqrt(sigma_sqs + tau^2) *
exp(-1/2 * (ys - mu_hat)^2 / (sigma_sqs + tau^2))))
}
# Make grid of tau values
grid_width <- 1/nsamp
p_tau_grid <- sapply(seq(grid_width, 50, grid_width), p_tau)
p_tau_grid <- cumsum(p_tau_grid/sum(p_tau_grid))
sample_quantile <- function(p, p_tau_grid, taus) {
p <- sort(p)
p_tau_grid <- sort(p_tau_grid)
j <- 1
indices <- vector(length = length(p))
for (i in 1:length(p)) {
while (p_tau_grid[j] < p[i]) {
j <-j + 1
}
indices[i] <- j
}
return (taus[indices])
}
# Generate tau samples
tau_samp <- sample_quantile(runif(nsamp), p_tau_grid,
seq(grid_width, 50, grid_width))
# Generate thetas and mus
calc_mu_hats <- function(tau) {
return (sum(1/(sigma_sqs + tau^2) * ys) / sum(1/(sigma_sqs + tau^2)))
}
calc_v_mus <- function(tau) {
return (1/sum(1/(sigma_sqs + tau^2)))
}
mu_hats <- sapply(tau_samp, calc_mu_hats)
v_mus <- sapply(tau_samp, calc_v_mus)
mu_samp <- rnorm(nsamp, mu_hats, sqrt(v_mus))
gen_theta_js <- function(j) {
rnorm(nsamp, (ys[j]/sigma_sqs[j] + mu_samp / tau_samp^2) /
(1/sigma_sqs[j] + 1 / tau_samp^2),
sqrt(1 / (1/sigma_sqs[j] + 1 / tau_samp^2)))
}
theta_samp <- sapply(1:length(ys), gen_theta_js)
# Probability of being the best
table_out <- table(apply(theta_samp, 1, which.max)) / nsamp
names(table_out) <- c("A", "B", "C", "D", "E", "F", "G", "H")
round(table_out, 3)
hist(tau_samp)
